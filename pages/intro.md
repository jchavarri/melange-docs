<h1 data-nav-order="2000-01-01">Intro</h1>

Melange is a fork of the ReScript compiler with emphasis on staying as much compatible as possible with the OCaml ecosystem.

## Melange features and goals

The primary goal of Melange is to improve compatibility with the OCaml ecosystem.

The secondary goal is to remain compatible with existing ReScript open source libraries. But as any other fork, it is hard to know for how long, or how much this compatibility will be maintained over time.

These goals lead to a series of features, that make Melange easy to use if you are already familiar with OCaml:

- Updated with new OCaml compiler versions
- Build Melange projects with Dune
- Use the latest improvements in tooling, for example [ppxlib](https://github.com/ocaml-ppx/ppxlib)
- Leverage OCaml editor integration plugins and tooling
- Remove build complexity from projects include native and JavaScript code written in OCaml (virtual libraries, shared `dune` configurations, ...)

## A bit of history

To understand better where Melange is coming from, it might help to go through some of the related projects that have appeared over the last decade or so.

### Js_of_ocaml

[Js_of_ocaml](https://github.com/ocsigen/js_of_ocaml/) is a project that was made public in 2011. In [the presentation paper](https://www.irif.fr/~balat/publications/vouillon_balat-js_of_ocaml.pdf) published in 2013, it's explicitly mentioned that one of its design goals was to remain as compatible as possible with
the OCaml compiler, without requiring a lot of maintenance work, as at the time the OCaml community was not excesively large.

To achieve this goal, Js_of_ocaml picks the bytecode generated by OCaml [batch compilation](https://ocaml.org/manual/comp.html) and generates JavaScript from it.
OCaml bytecode has a very stable interface, so Js_of_ocaml can easily upgrade to new versions of the compiler. Due to this design decision, it can also remain compatible with most of the
OCaml ecosystem, as long as the tools or libraries don't rely on C code.

The downside of using bytecode is that it gets harder to communicate with existing JavaScript code. For example, a Js_of_ocaml string is not compiled as a JavaScript string, so some conversion is needed for this and other types.

Another downside is that the resulting JavaScript is hard to read, as it is converted from a low-level representation like bytecode.

### BuckleScript

Then, in 2016, Bob Zhang suggests [on a Js_of_ocaml repository issue](https://github.com/ocsigen/js_of_ocaml/issues/338) the possibility to start converting to JavaScript from an earlier stage of the compilation process, instead of using bytecode. This proposal fundamentally diverges from Js_of_ocaml original design and goals, so he starts working on what will become BuckleScript.

BuckleScript gets some inspiration from Js_of_ocaml, for example in the way that JavaScript objects are represented with `Js.t`. But it differs from Js_of_ocaml in many ways: it can generate more readable and lighter code. It also generates one `.js` file per module, which makes it easier to integrate with existing JavaScript codebases. BuckleScript puts a big emphasis on interop with JavaScript code through a rich collection of attributes applied to `external` primitives.

### Reason

Around the same year, a project called [Reason](https://reasonml.github.io/) appears at Facebook. Led by Jordan Walke, the idea is to create an alternate syntax for OCaml that is closer to C and JavaScript. Even if Reason has no take on which platform the code is deployed —native applications binaries, or web applications using JavaScript as a target language—, BuckleScript adds first class support for Reason from early on. At that point, it becomes evident that the combination of Reason with BuckleScript is a great match: BuckleScript provides tools and infrastructure to work with JavaScript ecosystem, while Reason allows developers to write their programs in a syntax they are familiar with.

Over time, and with help of other Facebook employees and the community providing bindings to pervasive JavaScript libraries like React.js with [`reason-react`](https://github.com/reasonml/reason-react/), the combination of Reason and BuckleScript gains adoption.

### The Rebranding

However, at some point the goals of both BuckleScript and Reason projects become harder to reconcile. In August 2020, BuckleScript team decides to rename to ReScript, stops adding support for the latest versions of the Reason parser, and replaces it with a new parser with some changes in syntax. The reasons for the rebranding are explained in [the official ReScript blog post](https://rescript-lang.org/blog/bucklescript-is-rebranding).

The rebranding is trying to ease onboarding and adoption of the ReScript language, which will give the project more chances to compete with mainstream compiled-to-JavaScript languages like TypeScript. However, for many existing users of BuckleScript and Reason, it is the explicit confirmation of something that had been hinted implicitly before: ReScript goals are not compatible with providing a good integration with the OCaml ecosystem.

### Melange: back to OCaml

This is the point where Melange makes it appearance. A few weeks after The Rebranding, António Monteiro starts working on a fork of BuckleScript with a simple (not easy) goal: replace the [Ninja build system](https://ninja-build.org/), which BuckleScript had been using from its creation, with [Dune](https://dune.build/), which is the most used build system for OCaml projects.

This fork of BuckleScript is later named Melange. After finishing the switch from Ninja to Dune, another number of additional features get added, to bring it closer to OCaml. Some examples are the upgrade of the compiler version used by Melange to 4.12, or modelling the changes to the OCaml compiler that Melange uses as just a plain library, instead of a full fork of the whole compiler.

